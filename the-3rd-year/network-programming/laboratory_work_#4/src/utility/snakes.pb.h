// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: snakes.proto

#ifndef PROTOBUF_snakes_2eproto__INCLUDED
#define PROTOBUF_snakes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace snakes {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_snakes_2eproto();
void protobuf_AssignDesc_snakes_2eproto();
void protobuf_ShutdownFile_snakes_2eproto();

class GameConfig;
class GameMessage;
class GameMessage_AckMsg;
class GameMessage_AnnouncementMsg;
class GameMessage_ErrorMsg;
class GameMessage_JoinMsg;
class GameMessage_PingMsg;
class GameMessage_RoleChangeMsg;
class GameMessage_StateMsg;
class GameMessage_SteerMsg;
class GamePlayer;
class GamePlayers;
class GameState;
class GameState_Coord;
class GameState_Snake;

enum GameState_Snake_SnakeState {
  GameState_Snake_SnakeState_ALIVE = 0,
  GameState_Snake_SnakeState_ZOMBIE = 1
};
bool GameState_Snake_SnakeState_IsValid(int value);
const GameState_Snake_SnakeState GameState_Snake_SnakeState_SnakeState_MIN = GameState_Snake_SnakeState_ALIVE;
const GameState_Snake_SnakeState GameState_Snake_SnakeState_SnakeState_MAX = GameState_Snake_SnakeState_ZOMBIE;
const int GameState_Snake_SnakeState_SnakeState_ARRAYSIZE = GameState_Snake_SnakeState_SnakeState_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameState_Snake_SnakeState_descriptor();
inline const ::std::string& GameState_Snake_SnakeState_Name(GameState_Snake_SnakeState value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameState_Snake_SnakeState_descriptor(), value);
}
inline bool GameState_Snake_SnakeState_Parse(
    const ::std::string& name, GameState_Snake_SnakeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameState_Snake_SnakeState>(
    GameState_Snake_SnakeState_descriptor(), name, value);
}
enum NodeRole {
  NORMAL = 0,
  MASTER = 1,
  DEPUTY = 2,
  VIEWER = 3
};
bool NodeRole_IsValid(int value);
const NodeRole NodeRole_MIN = NORMAL;
const NodeRole NodeRole_MAX = VIEWER;
const int NodeRole_ARRAYSIZE = NodeRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeRole_descriptor();
inline const ::std::string& NodeRole_Name(NodeRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeRole_descriptor(), value);
}
inline bool NodeRole_Parse(
    const ::std::string& name, NodeRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeRole>(
    NodeRole_descriptor(), name, value);
}
enum PlayerType {
  HUMAN = 0,
  ROBOT = 1
};
bool PlayerType_IsValid(int value);
const PlayerType PlayerType_MIN = HUMAN;
const PlayerType PlayerType_MAX = ROBOT;
const int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerType_descriptor();
inline const ::std::string& PlayerType_Name(PlayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerType_descriptor(), value);
}
inline bool PlayerType_Parse(
    const ::std::string& name, PlayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum Direction {
  UP = 1,
  DOWN = 2,
  LEFT = 3,
  RIGHT = 4
};
bool Direction_IsValid(int value);
const Direction Direction_MIN = UP;
const Direction Direction_MAX = RIGHT;
const int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Direction_descriptor();
inline const ::std::string& Direction_Name(Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Direction_descriptor(), value);
}
inline bool Direction_Parse(
    const ::std::string& name, Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class GamePlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GamePlayer) */ {
 public:
  GamePlayer();
  virtual ~GamePlayer();

  GamePlayer(const GamePlayer& from);

  inline GamePlayer& operator=(const GamePlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePlayer& default_instance();

  void Swap(GamePlayer* other);

  // implements Message ----------------------------------------------

  inline GamePlayer* New() const { return New(NULL); }

  GamePlayer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePlayer& from);
  void MergeFrom(const GamePlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GamePlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required string ip_address = 3;
  bool has_ip_address() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 3;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // required int32 port = 4;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 4;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // required .snakes.NodeRole role = 5;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 5;
  ::snakes::NodeRole role() const;
  void set_role(::snakes::NodeRole value);

  // optional .snakes.PlayerType type = 6 [default = HUMAN];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::snakes::PlayerType type() const;
  void set_type(::snakes::PlayerType value);

  // required int32 score = 7;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 7;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:snakes.GamePlayer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_score();
  inline void clear_has_score();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 port_;
  int role_;
  int type_;
  ::google::protobuf::int32 score_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GamePlayer* default_instance_;
};
// -------------------------------------------------------------------

class GameConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameConfig) */ {
 public:
  GameConfig();
  virtual ~GameConfig();

  GameConfig(const GameConfig& from);

  inline GameConfig& operator=(const GameConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameConfig& default_instance();

  void Swap(GameConfig* other);

  // implements Message ----------------------------------------------

  inline GameConfig* New() const { return New(NULL); }

  GameConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameConfig& from);
  void MergeFrom(const GameConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 width = 1 [default = 40];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 2 [default = 30];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // optional int32 food_static = 3 [default = 1];
  bool has_food_static() const;
  void clear_food_static();
  static const int kFoodStaticFieldNumber = 3;
  ::google::protobuf::int32 food_static() const;
  void set_food_static(::google::protobuf::int32 value);

  // optional float food_per_player = 4 [default = 1];
  bool has_food_per_player() const;
  void clear_food_per_player();
  static const int kFoodPerPlayerFieldNumber = 4;
  float food_per_player() const;
  void set_food_per_player(float value);

  // optional int32 state_delay_ms = 5 [default = 1000];
  bool has_state_delay_ms() const;
  void clear_state_delay_ms();
  static const int kStateDelayMsFieldNumber = 5;
  ::google::protobuf::int32 state_delay_ms() const;
  void set_state_delay_ms(::google::protobuf::int32 value);

  // optional float dead_food_prob = 6 [default = 0.1];
  bool has_dead_food_prob() const;
  void clear_dead_food_prob();
  static const int kDeadFoodProbFieldNumber = 6;
  float dead_food_prob() const;
  void set_dead_food_prob(float value);

  // optional int32 ping_delay_ms = 7 [default = 100];
  bool has_ping_delay_ms() const;
  void clear_ping_delay_ms();
  static const int kPingDelayMsFieldNumber = 7;
  ::google::protobuf::int32 ping_delay_ms() const;
  void set_ping_delay_ms(::google::protobuf::int32 value);

  // optional int32 node_timeout_ms = 8 [default = 800];
  bool has_node_timeout_ms() const;
  void clear_node_timeout_ms();
  static const int kNodeTimeoutMsFieldNumber = 8;
  ::google::protobuf::int32 node_timeout_ms() const;
  void set_node_timeout_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:snakes.GameConfig)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_food_static();
  inline void clear_has_food_static();
  inline void set_has_food_per_player();
  inline void clear_has_food_per_player();
  inline void set_has_state_delay_ms();
  inline void clear_has_state_delay_ms();
  inline void set_has_dead_food_prob();
  inline void clear_has_dead_food_prob();
  inline void set_has_ping_delay_ms();
  inline void clear_has_ping_delay_ms();
  inline void set_has_node_timeout_ms();
  inline void clear_has_node_timeout_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 food_static_;
  float food_per_player_;
  ::google::protobuf::int32 state_delay_ms_;
  float dead_food_prob_;
  ::google::protobuf::int32 ping_delay_ms_;
  ::google::protobuf::int32 node_timeout_ms_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameConfig* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GamePlayers) */ {
 public:
  GamePlayers();
  virtual ~GamePlayers();

  GamePlayers(const GamePlayers& from);

  inline GamePlayers& operator=(const GamePlayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePlayers& default_instance();

  void Swap(GamePlayers* other);

  // implements Message ----------------------------------------------

  inline GamePlayers* New() const { return New(NULL); }

  GamePlayers* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePlayers& from);
  void MergeFrom(const GamePlayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GamePlayers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .snakes.GamePlayer players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::snakes::GamePlayer& players(int index) const;
  ::snakes::GamePlayer* mutable_players(int index);
  ::snakes::GamePlayer* add_players();
  ::google::protobuf::RepeatedPtrField< ::snakes::GamePlayer >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::snakes::GamePlayer >&
      players() const;

  // @@protoc_insertion_point(class_scope:snakes.GamePlayers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::snakes::GamePlayer > players_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GamePlayers* default_instance_;
};
// -------------------------------------------------------------------

class GameState_Coord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameState.Coord) */ {
 public:
  GameState_Coord();
  virtual ~GameState_Coord();

  GameState_Coord(const GameState_Coord& from);

  inline GameState_Coord& operator=(const GameState_Coord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState_Coord& default_instance();

  void Swap(GameState_Coord* other);

  // implements Message ----------------------------------------------

  inline GameState_Coord* New() const { return New(NULL); }

  GameState_Coord* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState_Coord& from);
  void MergeFrom(const GameState_Coord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameState_Coord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional sint32 y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:snakes.GameState.Coord)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameState_Coord* default_instance_;
};
// -------------------------------------------------------------------

class GameState_Snake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameState.Snake) */ {
 public:
  GameState_Snake();
  virtual ~GameState_Snake();

  GameState_Snake(const GameState_Snake& from);

  inline GameState_Snake& operator=(const GameState_Snake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState_Snake& default_instance();

  void Swap(GameState_Snake* other);

  // implements Message ----------------------------------------------

  inline GameState_Snake* New() const { return New(NULL); }

  GameState_Snake* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState_Snake& from);
  void MergeFrom(const GameState_Snake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameState_Snake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameState_Snake_SnakeState SnakeState;
  static const SnakeState ALIVE =
    GameState_Snake_SnakeState_ALIVE;
  static const SnakeState ZOMBIE =
    GameState_Snake_SnakeState_ZOMBIE;
  static inline bool SnakeState_IsValid(int value) {
    return GameState_Snake_SnakeState_IsValid(value);
  }
  static const SnakeState SnakeState_MIN =
    GameState_Snake_SnakeState_SnakeState_MIN;
  static const SnakeState SnakeState_MAX =
    GameState_Snake_SnakeState_SnakeState_MAX;
  static const int SnakeState_ARRAYSIZE =
    GameState_Snake_SnakeState_SnakeState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SnakeState_descriptor() {
    return GameState_Snake_SnakeState_descriptor();
  }
  static inline const ::std::string& SnakeState_Name(SnakeState value) {
    return GameState_Snake_SnakeState_Name(value);
  }
  static inline bool SnakeState_Parse(const ::std::string& name,
      SnakeState* value) {
    return GameState_Snake_SnakeState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int32 player_id() const;
  void set_player_id(::google::protobuf::int32 value);

  // repeated .snakes.GameState.Coord points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  const ::snakes::GameState_Coord& points(int index) const;
  ::snakes::GameState_Coord* mutable_points(int index);
  ::snakes::GameState_Coord* add_points();
  ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >&
      points() const;

  // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::snakes::GameState_Snake_SnakeState state() const;
  void set_state(::snakes::GameState_Snake_SnakeState value);

  // required .snakes.Direction head_direction = 4;
  bool has_head_direction() const;
  void clear_head_direction();
  static const int kHeadDirectionFieldNumber = 4;
  ::snakes::Direction head_direction() const;
  void set_head_direction(::snakes::Direction value);

  // @@protoc_insertion_point(class_scope:snakes.GameState.Snake)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_head_direction();
  inline void clear_has_head_direction();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord > points_;
  ::google::protobuf::int32 player_id_;
  int state_;
  int head_direction_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameState_Snake* default_instance_;
};
// -------------------------------------------------------------------

class GameState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameState) */ {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();

  void Swap(GameState* other);

  // implements Message ----------------------------------------------

  inline GameState* New() const { return New(NULL); }

  GameState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameState_Coord Coord;
  typedef GameState_Snake Snake;

  // accessors -------------------------------------------------------

  // required int32 state_order = 1;
  bool has_state_order() const;
  void clear_state_order();
  static const int kStateOrderFieldNumber = 1;
  ::google::protobuf::int32 state_order() const;
  void set_state_order(::google::protobuf::int32 value);

  // repeated .snakes.GameState.Snake snakes = 2;
  int snakes_size() const;
  void clear_snakes();
  static const int kSnakesFieldNumber = 2;
  const ::snakes::GameState_Snake& snakes(int index) const;
  ::snakes::GameState_Snake* mutable_snakes(int index);
  ::snakes::GameState_Snake* add_snakes();
  ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Snake >*
      mutable_snakes();
  const ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Snake >&
      snakes() const;

  // repeated .snakes.GameState.Coord foods = 3;
  int foods_size() const;
  void clear_foods();
  static const int kFoodsFieldNumber = 3;
  const ::snakes::GameState_Coord& foods(int index) const;
  ::snakes::GameState_Coord* mutable_foods(int index);
  ::snakes::GameState_Coord* add_foods();
  ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >*
      mutable_foods();
  const ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >&
      foods() const;

  // required .snakes.GamePlayers players = 4;
  bool has_players() const;
  void clear_players();
  static const int kPlayersFieldNumber = 4;
  const ::snakes::GamePlayers& players() const;
  ::snakes::GamePlayers* mutable_players();
  ::snakes::GamePlayers* release_players();
  void set_allocated_players(::snakes::GamePlayers* players);

  // required .snakes.GameConfig config = 5;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 5;
  const ::snakes::GameConfig& config() const;
  ::snakes::GameConfig* mutable_config();
  ::snakes::GameConfig* release_config();
  void set_allocated_config(::snakes::GameConfig* config);

  // @@protoc_insertion_point(class_scope:snakes.GameState)
 private:
  inline void set_has_state_order();
  inline void clear_has_state_order();
  inline void set_has_players();
  inline void clear_has_players();
  inline void set_has_config();
  inline void clear_has_config();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Snake > snakes_;
  ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord > foods_;
  ::snakes::GamePlayers* players_;
  ::snakes::GameConfig* config_;
  ::google::protobuf::int32 state_order_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameState* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_PingMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.PingMsg) */ {
 public:
  GameMessage_PingMsg();
  virtual ~GameMessage_PingMsg();

  GameMessage_PingMsg(const GameMessage_PingMsg& from);

  inline GameMessage_PingMsg& operator=(const GameMessage_PingMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_PingMsg& default_instance();

  void Swap(GameMessage_PingMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_PingMsg* New() const { return New(NULL); }

  GameMessage_PingMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_PingMsg& from);
  void MergeFrom(const GameMessage_PingMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_PingMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.PingMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_PingMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_SteerMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.SteerMsg) */ {
 public:
  GameMessage_SteerMsg();
  virtual ~GameMessage_SteerMsg();

  GameMessage_SteerMsg(const GameMessage_SteerMsg& from);

  inline GameMessage_SteerMsg& operator=(const GameMessage_SteerMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_SteerMsg& default_instance();

  void Swap(GameMessage_SteerMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_SteerMsg* New() const { return New(NULL); }

  GameMessage_SteerMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_SteerMsg& from);
  void MergeFrom(const GameMessage_SteerMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_SteerMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .snakes.Direction direction = 1;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 1;
  ::snakes::Direction direction() const;
  void set_direction(::snakes::Direction value);

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.SteerMsg)
 private:
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int direction_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_SteerMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_AckMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.AckMsg) */ {
 public:
  GameMessage_AckMsg();
  virtual ~GameMessage_AckMsg();

  GameMessage_AckMsg(const GameMessage_AckMsg& from);

  inline GameMessage_AckMsg& operator=(const GameMessage_AckMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_AckMsg& default_instance();

  void Swap(GameMessage_AckMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_AckMsg* New() const { return New(NULL); }

  GameMessage_AckMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_AckMsg& from);
  void MergeFrom(const GameMessage_AckMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_AckMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.AckMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_AckMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_StateMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.StateMsg) */ {
 public:
  GameMessage_StateMsg();
  virtual ~GameMessage_StateMsg();

  GameMessage_StateMsg(const GameMessage_StateMsg& from);

  inline GameMessage_StateMsg& operator=(const GameMessage_StateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_StateMsg& default_instance();

  void Swap(GameMessage_StateMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_StateMsg* New() const { return New(NULL); }

  GameMessage_StateMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_StateMsg& from);
  void MergeFrom(const GameMessage_StateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_StateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .snakes.GameState state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  const ::snakes::GameState& state() const;
  ::snakes::GameState* mutable_state();
  ::snakes::GameState* release_state();
  void set_allocated_state(::snakes::GameState* state);

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.StateMsg)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::snakes::GameState* state_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_StateMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_AnnouncementMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.AnnouncementMsg) */ {
 public:
  GameMessage_AnnouncementMsg();
  virtual ~GameMessage_AnnouncementMsg();

  GameMessage_AnnouncementMsg(const GameMessage_AnnouncementMsg& from);

  inline GameMessage_AnnouncementMsg& operator=(const GameMessage_AnnouncementMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_AnnouncementMsg& default_instance();

  void Swap(GameMessage_AnnouncementMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_AnnouncementMsg* New() const { return New(NULL); }

  GameMessage_AnnouncementMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_AnnouncementMsg& from);
  void MergeFrom(const GameMessage_AnnouncementMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_AnnouncementMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .snakes.GamePlayers players = 1;
  bool has_players() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::snakes::GamePlayers& players() const;
  ::snakes::GamePlayers* mutable_players();
  ::snakes::GamePlayers* release_players();
  void set_allocated_players(::snakes::GamePlayers* players);

  // required .snakes.GameConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::snakes::GameConfig& config() const;
  ::snakes::GameConfig* mutable_config();
  ::snakes::GameConfig* release_config();
  void set_allocated_config(::snakes::GameConfig* config);

  // optional bool can_join = 3 [default = true];
  bool has_can_join() const;
  void clear_can_join();
  static const int kCanJoinFieldNumber = 3;
  bool can_join() const;
  void set_can_join(bool value);

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.AnnouncementMsg)
 private:
  inline void set_has_players();
  inline void clear_has_players();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_can_join();
  inline void clear_has_can_join();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::snakes::GamePlayers* players_;
  ::snakes::GameConfig* config_;
  bool can_join_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_AnnouncementMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_JoinMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.JoinMsg) */ {
 public:
  GameMessage_JoinMsg();
  virtual ~GameMessage_JoinMsg();

  GameMessage_JoinMsg(const GameMessage_JoinMsg& from);

  inline GameMessage_JoinMsg& operator=(const GameMessage_JoinMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_JoinMsg& default_instance();

  void Swap(GameMessage_JoinMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_JoinMsg* New() const { return New(NULL); }

  GameMessage_JoinMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_JoinMsg& from);
  void MergeFrom(const GameMessage_JoinMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_JoinMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .snakes.PlayerType player_type = 1 [default = HUMAN];
  bool has_player_type() const;
  void clear_player_type();
  static const int kPlayerTypeFieldNumber = 1;
  ::snakes::PlayerType player_type() const;
  void set_player_type(::snakes::PlayerType value);

  // optional bool only_view = 2 [default = false];
  bool has_only_view() const;
  void clear_only_view();
  static const int kOnlyViewFieldNumber = 2;
  bool only_view() const;
  void set_only_view(bool value);

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.JoinMsg)
 private:
  inline void set_has_player_type();
  inline void clear_has_player_type();
  inline void set_has_only_view();
  inline void clear_has_only_view();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int player_type_;
  bool only_view_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_JoinMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_ErrorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.ErrorMsg) */ {
 public:
  GameMessage_ErrorMsg();
  virtual ~GameMessage_ErrorMsg();

  GameMessage_ErrorMsg(const GameMessage_ErrorMsg& from);

  inline GameMessage_ErrorMsg& operator=(const GameMessage_ErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_ErrorMsg& default_instance();

  void Swap(GameMessage_ErrorMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_ErrorMsg* New() const { return New(NULL); }

  GameMessage_ErrorMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_ErrorMsg& from);
  void MergeFrom(const GameMessage_ErrorMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_ErrorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error_message = 1;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 1;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.ErrorMsg)
 private:
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_ErrorMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage_RoleChangeMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.RoleChangeMsg) */ {
 public:
  GameMessage_RoleChangeMsg();
  virtual ~GameMessage_RoleChangeMsg();

  GameMessage_RoleChangeMsg(const GameMessage_RoleChangeMsg& from);

  inline GameMessage_RoleChangeMsg& operator=(const GameMessage_RoleChangeMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage_RoleChangeMsg& default_instance();

  void Swap(GameMessage_RoleChangeMsg* other);

  // implements Message ----------------------------------------------

  inline GameMessage_RoleChangeMsg* New() const { return New(NULL); }

  GameMessage_RoleChangeMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage_RoleChangeMsg& from);
  void MergeFrom(const GameMessage_RoleChangeMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage_RoleChangeMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .snakes.NodeRole sender_role = 1;
  bool has_sender_role() const;
  void clear_sender_role();
  static const int kSenderRoleFieldNumber = 1;
  ::snakes::NodeRole sender_role() const;
  void set_sender_role(::snakes::NodeRole value);

  // optional .snakes.NodeRole receiver_role = 2;
  bool has_receiver_role() const;
  void clear_receiver_role();
  static const int kReceiverRoleFieldNumber = 2;
  ::snakes::NodeRole receiver_role() const;
  void set_receiver_role(::snakes::NodeRole value);

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.RoleChangeMsg)
 private:
  inline void set_has_sender_role();
  inline void clear_has_sender_role();
  inline void set_has_receiver_role();
  inline void clear_has_receiver_role();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int sender_role_;
  int receiver_role_;
  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage_RoleChangeMsg* default_instance_;
};
// -------------------------------------------------------------------

class GameMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage) */ {
 public:
  GameMessage();
  virtual ~GameMessage();

  GameMessage(const GameMessage& from);

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage& default_instance();

  enum TypeCase {
    kPing = 2,
    kSteer = 3,
    kAck = 4,
    kState = 5,
    kAnnouncement = 6,
    kJoin = 7,
    kError = 8,
    kRoleChange = 9,
    TYPE_NOT_SET = 0,
  };

  void Swap(GameMessage* other);

  // implements Message ----------------------------------------------

  inline GameMessage* New() const { return New(NULL); }

  GameMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage& from);
  void MergeFrom(const GameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameMessage_PingMsg PingMsg;
  typedef GameMessage_SteerMsg SteerMsg;
  typedef GameMessage_AckMsg AckMsg;
  typedef GameMessage_StateMsg StateMsg;
  typedef GameMessage_AnnouncementMsg AnnouncementMsg;
  typedef GameMessage_JoinMsg JoinMsg;
  typedef GameMessage_ErrorMsg ErrorMsg;
  typedef GameMessage_RoleChangeMsg RoleChangeMsg;

  // accessors -------------------------------------------------------

  // required int64 msg_seq = 1;
  bool has_msg_seq() const;
  void clear_msg_seq();
  static const int kMsgSeqFieldNumber = 1;
  ::google::protobuf::int64 msg_seq() const;
  void set_msg_seq(::google::protobuf::int64 value);

  // optional int32 sender_id = 10;
  bool has_sender_id() const;
  void clear_sender_id();
  static const int kSenderIdFieldNumber = 10;
  ::google::protobuf::int32 sender_id() const;
  void set_sender_id(::google::protobuf::int32 value);

  // optional int32 receiver_id = 11;
  bool has_receiver_id() const;
  void clear_receiver_id();
  static const int kReceiverIdFieldNumber = 11;
  ::google::protobuf::int32 receiver_id() const;
  void set_receiver_id(::google::protobuf::int32 value);

  // optional .snakes.GameMessage.PingMsg ping = 2;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 2;
  const ::snakes::GameMessage_PingMsg& ping() const;
  ::snakes::GameMessage_PingMsg* mutable_ping();
  ::snakes::GameMessage_PingMsg* release_ping();
  void set_allocated_ping(::snakes::GameMessage_PingMsg* ping);

  // optional .snakes.GameMessage.SteerMsg steer = 3;
  bool has_steer() const;
  void clear_steer();
  static const int kSteerFieldNumber = 3;
  const ::snakes::GameMessage_SteerMsg& steer() const;
  ::snakes::GameMessage_SteerMsg* mutable_steer();
  ::snakes::GameMessage_SteerMsg* release_steer();
  void set_allocated_steer(::snakes::GameMessage_SteerMsg* steer);

  // optional .snakes.GameMessage.AckMsg ack = 4;
  bool has_ack() const;
  void clear_ack();
  static const int kAckFieldNumber = 4;
  const ::snakes::GameMessage_AckMsg& ack() const;
  ::snakes::GameMessage_AckMsg* mutable_ack();
  ::snakes::GameMessage_AckMsg* release_ack();
  void set_allocated_ack(::snakes::GameMessage_AckMsg* ack);

  // optional .snakes.GameMessage.StateMsg state = 5;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  const ::snakes::GameMessage_StateMsg& state() const;
  ::snakes::GameMessage_StateMsg* mutable_state();
  ::snakes::GameMessage_StateMsg* release_state();
  void set_allocated_state(::snakes::GameMessage_StateMsg* state);

  // optional .snakes.GameMessage.AnnouncementMsg announcement = 6;
  bool has_announcement() const;
  void clear_announcement();
  static const int kAnnouncementFieldNumber = 6;
  const ::snakes::GameMessage_AnnouncementMsg& announcement() const;
  ::snakes::GameMessage_AnnouncementMsg* mutable_announcement();
  ::snakes::GameMessage_AnnouncementMsg* release_announcement();
  void set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement);

  // optional .snakes.GameMessage.JoinMsg join = 7;
  bool has_join() const;
  void clear_join();
  static const int kJoinFieldNumber = 7;
  const ::snakes::GameMessage_JoinMsg& join() const;
  ::snakes::GameMessage_JoinMsg* mutable_join();
  ::snakes::GameMessage_JoinMsg* release_join();
  void set_allocated_join(::snakes::GameMessage_JoinMsg* join);

  // optional .snakes.GameMessage.ErrorMsg error = 8;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 8;
  const ::snakes::GameMessage_ErrorMsg& error() const;
  ::snakes::GameMessage_ErrorMsg* mutable_error();
  ::snakes::GameMessage_ErrorMsg* release_error();
  void set_allocated_error(::snakes::GameMessage_ErrorMsg* error);

  // optional .snakes.GameMessage.RoleChangeMsg role_change = 9;
  bool has_role_change() const;
  void clear_role_change();
  static const int kRoleChangeFieldNumber = 9;
  const ::snakes::GameMessage_RoleChangeMsg& role_change() const;
  ::snakes::GameMessage_RoleChangeMsg* mutable_role_change();
  ::snakes::GameMessage_RoleChangeMsg* release_role_change();
  void set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:snakes.GameMessage)
 private:
  inline void set_has_msg_seq();
  inline void clear_has_msg_seq();
  inline void set_has_sender_id();
  inline void clear_has_sender_id();
  inline void set_has_receiver_id();
  inline void clear_has_receiver_id();
  inline void set_has_ping();
  inline void set_has_steer();
  inline void set_has_ack();
  inline void set_has_state();
  inline void set_has_announcement();
  inline void set_has_join();
  inline void set_has_error();
  inline void set_has_role_change();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 msg_seq_;
  ::google::protobuf::int32 sender_id_;
  ::google::protobuf::int32 receiver_id_;
  union TypeUnion {
    TypeUnion() {}
    ::snakes::GameMessage_PingMsg* ping_;
    ::snakes::GameMessage_SteerMsg* steer_;
    ::snakes::GameMessage_AckMsg* ack_;
    ::snakes::GameMessage_StateMsg* state_;
    ::snakes::GameMessage_AnnouncementMsg* announcement_;
    ::snakes::GameMessage_JoinMsg* join_;
    ::snakes::GameMessage_ErrorMsg* error_;
    ::snakes::GameMessage_RoleChangeMsg* role_change_;
  } Type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_snakes_2eproto();
  friend void protobuf_AssignDesc_snakes_2eproto();
  friend void protobuf_ShutdownFile_snakes_2eproto();

  void InitAsDefaultInstance();
  static GameMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GamePlayer

// required string name = 1;
inline bool GamePlayer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GamePlayer::name() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GamePlayer::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.name)
}
inline void GamePlayer::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:snakes.GamePlayer.name)
}
inline void GamePlayer::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:snakes.GamePlayer.name)
}
inline ::std::string* GamePlayer::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GamePlayer::release_name() {
  // @@protoc_insertion_point(field_release:snakes.GamePlayer.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GamePlayer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:snakes.GamePlayer.name)
}

// required int32 id = 2;
inline bool GamePlayer::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayer::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayer::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GamePlayer::id() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.id)
  return id_;
}
inline void GamePlayer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.id)
}

// required string ip_address = 3;
inline bool GamePlayer::has_ip_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayer::set_has_ip_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayer::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayer::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip_address();
}
inline const ::std::string& GamePlayer::ip_address() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GamePlayer::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.ip_address)
}
inline void GamePlayer::set_ip_address(const char* value) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:snakes.GamePlayer.ip_address)
}
inline void GamePlayer::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:snakes.GamePlayer.ip_address)
}
inline ::std::string* GamePlayer::mutable_ip_address() {
  set_has_ip_address();
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayer.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GamePlayer::release_ip_address() {
  // @@protoc_insertion_point(field_release:snakes.GamePlayer.ip_address)
  clear_has_ip_address();
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GamePlayer::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    set_has_ip_address();
  } else {
    clear_has_ip_address();
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:snakes.GamePlayer.ip_address)
}

// required int32 port = 4;
inline bool GamePlayer::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GamePlayer::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GamePlayer::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GamePlayer::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 GamePlayer::port() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.port)
  return port_;
}
inline void GamePlayer::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.port)
}

// required .snakes.NodeRole role = 5;
inline bool GamePlayer::has_role() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GamePlayer::set_has_role() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GamePlayer::clear_has_role() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GamePlayer::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::snakes::NodeRole GamePlayer::role() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.role)
  return static_cast< ::snakes::NodeRole >(role_);
}
inline void GamePlayer::set_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  set_has_role();
  role_ = value;
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.role)
}

// optional .snakes.PlayerType type = 6 [default = HUMAN];
inline bool GamePlayer::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GamePlayer::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GamePlayer::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GamePlayer::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::snakes::PlayerType GamePlayer::type() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.type)
  return static_cast< ::snakes::PlayerType >(type_);
}
inline void GamePlayer::set_type(::snakes::PlayerType value) {
  assert(::snakes::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.type)
}

// required int32 score = 7;
inline bool GamePlayer::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GamePlayer::set_has_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GamePlayer::clear_has_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GamePlayer::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 GamePlayer::score() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.score)
  return score_;
}
inline void GamePlayer::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.score)
}

// -------------------------------------------------------------------

// GameConfig

// optional int32 width = 1 [default = 40];
inline bool GameConfig::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameConfig::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameConfig::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameConfig::clear_width() {
  width_ = 40;
  clear_has_width();
}
inline ::google::protobuf::int32 GameConfig::width() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.width)
  return width_;
}
inline void GameConfig::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.width)
}

// optional int32 height = 2 [default = 30];
inline bool GameConfig::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameConfig::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameConfig::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameConfig::clear_height() {
  height_ = 30;
  clear_has_height();
}
inline ::google::protobuf::int32 GameConfig::height() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.height)
  return height_;
}
inline void GameConfig::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.height)
}

// optional int32 food_static = 3 [default = 1];
inline bool GameConfig::has_food_static() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameConfig::set_has_food_static() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameConfig::clear_has_food_static() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameConfig::clear_food_static() {
  food_static_ = 1;
  clear_has_food_static();
}
inline ::google::protobuf::int32 GameConfig::food_static() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.food_static)
  return food_static_;
}
inline void GameConfig::set_food_static(::google::protobuf::int32 value) {
  set_has_food_static();
  food_static_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.food_static)
}

// optional float food_per_player = 4 [default = 1];
inline bool GameConfig::has_food_per_player() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameConfig::set_has_food_per_player() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameConfig::clear_has_food_per_player() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameConfig::clear_food_per_player() {
  food_per_player_ = 1;
  clear_has_food_per_player();
}
inline float GameConfig::food_per_player() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.food_per_player)
  return food_per_player_;
}
inline void GameConfig::set_food_per_player(float value) {
  set_has_food_per_player();
  food_per_player_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.food_per_player)
}

// optional int32 state_delay_ms = 5 [default = 1000];
inline bool GameConfig::has_state_delay_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameConfig::set_has_state_delay_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameConfig::clear_has_state_delay_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameConfig::clear_state_delay_ms() {
  state_delay_ms_ = 1000;
  clear_has_state_delay_ms();
}
inline ::google::protobuf::int32 GameConfig::state_delay_ms() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.state_delay_ms)
  return state_delay_ms_;
}
inline void GameConfig::set_state_delay_ms(::google::protobuf::int32 value) {
  set_has_state_delay_ms();
  state_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.state_delay_ms)
}

// optional float dead_food_prob = 6 [default = 0.1];
inline bool GameConfig::has_dead_food_prob() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameConfig::set_has_dead_food_prob() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameConfig::clear_has_dead_food_prob() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameConfig::clear_dead_food_prob() {
  dead_food_prob_ = 0.1f;
  clear_has_dead_food_prob();
}
inline float GameConfig::dead_food_prob() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.dead_food_prob)
  return dead_food_prob_;
}
inline void GameConfig::set_dead_food_prob(float value) {
  set_has_dead_food_prob();
  dead_food_prob_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.dead_food_prob)
}

// optional int32 ping_delay_ms = 7 [default = 100];
inline bool GameConfig::has_ping_delay_ms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameConfig::set_has_ping_delay_ms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameConfig::clear_has_ping_delay_ms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameConfig::clear_ping_delay_ms() {
  ping_delay_ms_ = 100;
  clear_has_ping_delay_ms();
}
inline ::google::protobuf::int32 GameConfig::ping_delay_ms() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.ping_delay_ms)
  return ping_delay_ms_;
}
inline void GameConfig::set_ping_delay_ms(::google::protobuf::int32 value) {
  set_has_ping_delay_ms();
  ping_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.ping_delay_ms)
}

// optional int32 node_timeout_ms = 8 [default = 800];
inline bool GameConfig::has_node_timeout_ms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameConfig::set_has_node_timeout_ms() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameConfig::clear_has_node_timeout_ms() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameConfig::clear_node_timeout_ms() {
  node_timeout_ms_ = 800;
  clear_has_node_timeout_ms();
}
inline ::google::protobuf::int32 GameConfig::node_timeout_ms() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.node_timeout_ms)
  return node_timeout_ms_;
}
inline void GameConfig::set_node_timeout_ms(::google::protobuf::int32 value) {
  set_has_node_timeout_ms();
  node_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameConfig.node_timeout_ms)
}

// -------------------------------------------------------------------

// GamePlayers

// repeated .snakes.GamePlayer players = 1;
inline int GamePlayers::players_size() const {
  return players_.size();
}
inline void GamePlayers::clear_players() {
  players_.Clear();
}
inline const ::snakes::GamePlayer& GamePlayers::players(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayers.players)
  return players_.Get(index);
}
inline ::snakes::GamePlayer* GamePlayers::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayers.players)
  return players_.Mutable(index);
}
inline ::snakes::GamePlayer* GamePlayers::add_players() {
  // @@protoc_insertion_point(field_add:snakes.GamePlayers.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::snakes::GamePlayer >*
GamePlayers::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GamePlayers.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::snakes::GamePlayer >&
GamePlayers::players() const {
  // @@protoc_insertion_point(field_list:snakes.GamePlayers.players)
  return players_;
}

// -------------------------------------------------------------------

// GameState_Coord

// optional sint32 x = 1 [default = 0];
inline bool GameState_Coord::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameState_Coord::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameState_Coord::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameState_Coord::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 GameState_Coord::x() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Coord.x)
  return x_;
}
inline void GameState_Coord::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameState.Coord.x)
}

// optional sint32 y = 2 [default = 0];
inline bool GameState_Coord::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameState_Coord::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameState_Coord::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameState_Coord::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 GameState_Coord::y() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Coord.y)
  return y_;
}
inline void GameState_Coord::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameState.Coord.y)
}

// -------------------------------------------------------------------

// GameState_Snake

// required int32 player_id = 1;
inline bool GameState_Snake::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameState_Snake::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameState_Snake::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameState_Snake::clear_player_id() {
  player_id_ = 0;
  clear_has_player_id();
}
inline ::google::protobuf::int32 GameState_Snake::player_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.player_id)
  return player_id_;
}
inline void GameState_Snake::set_player_id(::google::protobuf::int32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.player_id)
}

// repeated .snakes.GameState.Coord points = 2;
inline int GameState_Snake::points_size() const {
  return points_.size();
}
inline void GameState_Snake::clear_points() {
  points_.Clear();
}
inline const ::snakes::GameState_Coord& GameState_Snake::points(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.points)
  return points_.Get(index);
}
inline ::snakes::GameState_Coord* GameState_Snake::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.Snake.points)
  return points_.Mutable(index);
}
inline ::snakes::GameState_Coord* GameState_Snake::add_points() {
  // @@protoc_insertion_point(field_add:snakes.GameState.Snake.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >*
GameState_Snake::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.Snake.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >&
GameState_Snake::points() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.Snake.points)
  return points_;
}

// required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
inline bool GameState_Snake::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameState_Snake::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameState_Snake::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameState_Snake::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::snakes::GameState_Snake_SnakeState GameState_Snake::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.state)
  return static_cast< ::snakes::GameState_Snake_SnakeState >(state_);
}
inline void GameState_Snake::set_state(::snakes::GameState_Snake_SnakeState value) {
  assert(::snakes::GameState_Snake_SnakeState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.state)
}

// required .snakes.Direction head_direction = 4;
inline bool GameState_Snake::has_head_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameState_Snake::set_has_head_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameState_Snake::clear_has_head_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameState_Snake::clear_head_direction() {
  head_direction_ = 1;
  clear_has_head_direction();
}
inline ::snakes::Direction GameState_Snake::head_direction() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.head_direction)
  return static_cast< ::snakes::Direction >(head_direction_);
}
inline void GameState_Snake::set_head_direction(::snakes::Direction value) {
  assert(::snakes::Direction_IsValid(value));
  set_has_head_direction();
  head_direction_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.head_direction)
}

// -------------------------------------------------------------------

// GameState

// required int32 state_order = 1;
inline bool GameState::has_state_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameState::set_has_state_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameState::clear_has_state_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameState::clear_state_order() {
  state_order_ = 0;
  clear_has_state_order();
}
inline ::google::protobuf::int32 GameState::state_order() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.state_order)
  return state_order_;
}
inline void GameState::set_state_order(::google::protobuf::int32 value) {
  set_has_state_order();
  state_order_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameState.state_order)
}

// repeated .snakes.GameState.Snake snakes = 2;
inline int GameState::snakes_size() const {
  return snakes_.size();
}
inline void GameState::clear_snakes() {
  snakes_.Clear();
}
inline const ::snakes::GameState_Snake& GameState::snakes(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.snakes)
  return snakes_.Get(index);
}
inline ::snakes::GameState_Snake* GameState::mutable_snakes(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.snakes)
  return snakes_.Mutable(index);
}
inline ::snakes::GameState_Snake* GameState::add_snakes() {
  // @@protoc_insertion_point(field_add:snakes.GameState.snakes)
  return snakes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Snake >*
GameState::mutable_snakes() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.snakes)
  return &snakes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Snake >&
GameState::snakes() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.snakes)
  return snakes_;
}

// repeated .snakes.GameState.Coord foods = 3;
inline int GameState::foods_size() const {
  return foods_.size();
}
inline void GameState::clear_foods() {
  foods_.Clear();
}
inline const ::snakes::GameState_Coord& GameState::foods(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.foods)
  return foods_.Get(index);
}
inline ::snakes::GameState_Coord* GameState::mutable_foods(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.foods)
  return foods_.Mutable(index);
}
inline ::snakes::GameState_Coord* GameState::add_foods() {
  // @@protoc_insertion_point(field_add:snakes.GameState.foods)
  return foods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >*
GameState::mutable_foods() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.foods)
  return &foods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::snakes::GameState_Coord >&
GameState::foods() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.foods)
  return foods_;
}

// required .snakes.GamePlayers players = 4;
inline bool GameState::has_players() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameState::set_has_players() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameState::clear_has_players() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameState::clear_players() {
  if (players_ != NULL) players_->::snakes::GamePlayers::Clear();
  clear_has_players();
}
inline const ::snakes::GamePlayers& GameState::players() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.players)
  return players_ != NULL ? *players_ : *default_instance_->players_;
}
inline ::snakes::GamePlayers* GameState::mutable_players() {
  set_has_players();
  if (players_ == NULL) {
    players_ = new ::snakes::GamePlayers;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameState.players)
  return players_;
}
inline ::snakes::GamePlayers* GameState::release_players() {
  // @@protoc_insertion_point(field_release:snakes.GameState.players)
  clear_has_players();
  ::snakes::GamePlayers* temp = players_;
  players_ = NULL;
  return temp;
}
inline void GameState::set_allocated_players(::snakes::GamePlayers* players) {
  delete players_;
  players_ = players;
  if (players) {
    set_has_players();
  } else {
    clear_has_players();
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameState.players)
}

// required .snakes.GameConfig config = 5;
inline bool GameState::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameState::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameState::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameState::clear_config() {
  if (config_ != NULL) config_->::snakes::GameConfig::Clear();
  clear_has_config();
}
inline const ::snakes::GameConfig& GameState::config() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::snakes::GameConfig* GameState::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::snakes::GameConfig;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameState.config)
  return config_;
}
inline ::snakes::GameConfig* GameState::release_config() {
  // @@protoc_insertion_point(field_release:snakes.GameState.config)
  clear_has_config();
  ::snakes::GameConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GameState::set_allocated_config(::snakes::GameConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameState.config)
}

// -------------------------------------------------------------------

// GameMessage_PingMsg

// -------------------------------------------------------------------

// GameMessage_SteerMsg

// required .snakes.Direction direction = 1;
inline bool GameMessage_SteerMsg::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage_SteerMsg::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage_SteerMsg::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage_SteerMsg::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::snakes::Direction GameMessage_SteerMsg::direction() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.SteerMsg.direction)
  return static_cast< ::snakes::Direction >(direction_);
}
inline void GameMessage_SteerMsg::set_direction(::snakes::Direction value) {
  assert(::snakes::Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.SteerMsg.direction)
}

// -------------------------------------------------------------------

// GameMessage_AckMsg

// -------------------------------------------------------------------

// GameMessage_StateMsg

// required .snakes.GameState state = 1;
inline bool GameMessage_StateMsg::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage_StateMsg::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage_StateMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage_StateMsg::clear_state() {
  if (state_ != NULL) state_->::snakes::GameState::Clear();
  clear_has_state();
}
inline const ::snakes::GameState& GameMessage_StateMsg::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.StateMsg.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::snakes::GameState* GameMessage_StateMsg::mutable_state() {
  set_has_state();
  if (state_ == NULL) {
    state_ = new ::snakes::GameState;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.StateMsg.state)
  return state_;
}
inline ::snakes::GameState* GameMessage_StateMsg::release_state() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.StateMsg.state)
  clear_has_state();
  ::snakes::GameState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GameMessage_StateMsg::set_allocated_state(::snakes::GameState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.StateMsg.state)
}

// -------------------------------------------------------------------

// GameMessage_AnnouncementMsg

// required .snakes.GamePlayers players = 1;
inline bool GameMessage_AnnouncementMsg::has_players() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage_AnnouncementMsg::set_has_players() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage_AnnouncementMsg::clear_has_players() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage_AnnouncementMsg::clear_players() {
  if (players_ != NULL) players_->::snakes::GamePlayers::Clear();
  clear_has_players();
}
inline const ::snakes::GamePlayers& GameMessage_AnnouncementMsg::players() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.AnnouncementMsg.players)
  return players_ != NULL ? *players_ : *default_instance_->players_;
}
inline ::snakes::GamePlayers* GameMessage_AnnouncementMsg::mutable_players() {
  set_has_players();
  if (players_ == NULL) {
    players_ = new ::snakes::GamePlayers;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.AnnouncementMsg.players)
  return players_;
}
inline ::snakes::GamePlayers* GameMessage_AnnouncementMsg::release_players() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.AnnouncementMsg.players)
  clear_has_players();
  ::snakes::GamePlayers* temp = players_;
  players_ = NULL;
  return temp;
}
inline void GameMessage_AnnouncementMsg::set_allocated_players(::snakes::GamePlayers* players) {
  delete players_;
  players_ = players;
  if (players) {
    set_has_players();
  } else {
    clear_has_players();
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.AnnouncementMsg.players)
}

// required .snakes.GameConfig config = 2;
inline bool GameMessage_AnnouncementMsg::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMessage_AnnouncementMsg::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMessage_AnnouncementMsg::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMessage_AnnouncementMsg::clear_config() {
  if (config_ != NULL) config_->::snakes::GameConfig::Clear();
  clear_has_config();
}
inline const ::snakes::GameConfig& GameMessage_AnnouncementMsg::config() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.AnnouncementMsg.config)
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::snakes::GameConfig* GameMessage_AnnouncementMsg::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::snakes::GameConfig;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.AnnouncementMsg.config)
  return config_;
}
inline ::snakes::GameConfig* GameMessage_AnnouncementMsg::release_config() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.AnnouncementMsg.config)
  clear_has_config();
  ::snakes::GameConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GameMessage_AnnouncementMsg::set_allocated_config(::snakes::GameConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.AnnouncementMsg.config)
}

// optional bool can_join = 3 [default = true];
inline bool GameMessage_AnnouncementMsg::has_can_join() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMessage_AnnouncementMsg::set_has_can_join() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMessage_AnnouncementMsg::clear_has_can_join() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMessage_AnnouncementMsg::clear_can_join() {
  can_join_ = true;
  clear_has_can_join();
}
inline bool GameMessage_AnnouncementMsg::can_join() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.AnnouncementMsg.can_join)
  return can_join_;
}
inline void GameMessage_AnnouncementMsg::set_can_join(bool value) {
  set_has_can_join();
  can_join_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.AnnouncementMsg.can_join)
}

// -------------------------------------------------------------------

// GameMessage_JoinMsg

// optional .snakes.PlayerType player_type = 1 [default = HUMAN];
inline bool GameMessage_JoinMsg::has_player_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage_JoinMsg::set_has_player_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage_JoinMsg::clear_has_player_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage_JoinMsg::clear_player_type() {
  player_type_ = 0;
  clear_has_player_type();
}
inline ::snakes::PlayerType GameMessage_JoinMsg::player_type() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.player_type)
  return static_cast< ::snakes::PlayerType >(player_type_);
}
inline void GameMessage_JoinMsg::set_player_type(::snakes::PlayerType value) {
  assert(::snakes::PlayerType_IsValid(value));
  set_has_player_type();
  player_type_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.player_type)
}

// optional bool only_view = 2 [default = false];
inline bool GameMessage_JoinMsg::has_only_view() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMessage_JoinMsg::set_has_only_view() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMessage_JoinMsg::clear_has_only_view() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMessage_JoinMsg::clear_only_view() {
  only_view_ = false;
  clear_has_only_view();
}
inline bool GameMessage_JoinMsg::only_view() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.only_view)
  return only_view_;
}
inline void GameMessage_JoinMsg::set_only_view(bool value) {
  set_has_only_view();
  only_view_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.only_view)
}

// required string name = 3;
inline bool GameMessage_JoinMsg::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMessage_JoinMsg::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMessage_JoinMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMessage_JoinMsg::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GameMessage_JoinMsg::name() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMessage_JoinMsg::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.name)
}
inline void GameMessage_JoinMsg::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:snakes.GameMessage.JoinMsg.name)
}
inline void GameMessage_JoinMsg::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:snakes.GameMessage.JoinMsg.name)
}
inline ::std::string* GameMessage_JoinMsg::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.JoinMsg.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameMessage_JoinMsg::release_name() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.JoinMsg.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMessage_JoinMsg::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.JoinMsg.name)
}

// -------------------------------------------------------------------

// GameMessage_ErrorMsg

// required string error_message = 1;
inline bool GameMessage_ErrorMsg::has_error_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage_ErrorMsg::set_has_error_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage_ErrorMsg::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage_ErrorMsg::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& GameMessage_ErrorMsg::error_message() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ErrorMsg.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMessage_ErrorMsg::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.ErrorMsg.error_message)
}
inline void GameMessage_ErrorMsg::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:snakes.GameMessage.ErrorMsg.error_message)
}
inline void GameMessage_ErrorMsg::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:snakes.GameMessage.ErrorMsg.error_message)
}
inline ::std::string* GameMessage_ErrorMsg::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ErrorMsg.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameMessage_ErrorMsg::release_error_message() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ErrorMsg.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMessage_ErrorMsg::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ErrorMsg.error_message)
}

// -------------------------------------------------------------------

// GameMessage_RoleChangeMsg

// optional .snakes.NodeRole sender_role = 1;
inline bool GameMessage_RoleChangeMsg::has_sender_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage_RoleChangeMsg::set_has_sender_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage_RoleChangeMsg::clear_has_sender_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage_RoleChangeMsg::clear_sender_role() {
  sender_role_ = 0;
  clear_has_sender_role();
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::sender_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.RoleChangeMsg.sender_role)
  return static_cast< ::snakes::NodeRole >(sender_role_);
}
inline void GameMessage_RoleChangeMsg::set_sender_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  set_has_sender_role();
  sender_role_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.RoleChangeMsg.sender_role)
}

// optional .snakes.NodeRole receiver_role = 2;
inline bool GameMessage_RoleChangeMsg::has_receiver_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMessage_RoleChangeMsg::set_has_receiver_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMessage_RoleChangeMsg::clear_has_receiver_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMessage_RoleChangeMsg::clear_receiver_role() {
  receiver_role_ = 0;
  clear_has_receiver_role();
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::receiver_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.RoleChangeMsg.receiver_role)
  return static_cast< ::snakes::NodeRole >(receiver_role_);
}
inline void GameMessage_RoleChangeMsg::set_receiver_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  set_has_receiver_role();
  receiver_role_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.RoleChangeMsg.receiver_role)
}

// -------------------------------------------------------------------

// GameMessage

// required int64 msg_seq = 1;
inline bool GameMessage::has_msg_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage::set_has_msg_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage::clear_has_msg_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage::clear_msg_seq() {
  msg_seq_ = GOOGLE_LONGLONG(0);
  clear_has_msg_seq();
}
inline ::google::protobuf::int64 GameMessage::msg_seq() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.msg_seq)
  return msg_seq_;
}
inline void GameMessage::set_msg_seq(::google::protobuf::int64 value) {
  set_has_msg_seq();
  msg_seq_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.msg_seq)
}

// optional int32 sender_id = 10;
inline bool GameMessage::has_sender_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMessage::set_has_sender_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMessage::clear_has_sender_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMessage::clear_sender_id() {
  sender_id_ = 0;
  clear_has_sender_id();
}
inline ::google::protobuf::int32 GameMessage::sender_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.sender_id)
  return sender_id_;
}
inline void GameMessage::set_sender_id(::google::protobuf::int32 value) {
  set_has_sender_id();
  sender_id_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.sender_id)
}

// optional int32 receiver_id = 11;
inline bool GameMessage::has_receiver_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMessage::set_has_receiver_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMessage::clear_has_receiver_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMessage::clear_receiver_id() {
  receiver_id_ = 0;
  clear_has_receiver_id();
}
inline ::google::protobuf::int32 GameMessage::receiver_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.receiver_id)
  return receiver_id_;
}
inline void GameMessage::set_receiver_id(::google::protobuf::int32 value) {
  set_has_receiver_id();
  receiver_id_ = value;
  // @@protoc_insertion_point(field_set:snakes.GameMessage.receiver_id)
}

// optional .snakes.GameMessage.PingMsg ping = 2;
inline bool GameMessage::has_ping() const {
  return Type_case() == kPing;
}
inline void GameMessage::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void GameMessage::clear_ping() {
  if (has_ping()) {
    delete Type_.ping_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_PingMsg& GameMessage::ping() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ping)
  return has_ping()
      ? *Type_.ping_
      : ::snakes::GameMessage_PingMsg::default_instance();
}
inline ::snakes::GameMessage_PingMsg* GameMessage::mutable_ping() {
  if (!has_ping()) {
    clear_Type();
    set_has_ping();
    Type_.ping_ = new ::snakes::GameMessage_PingMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ping)
  return Type_.ping_;
}
inline ::snakes::GameMessage_PingMsg* GameMessage::release_ping() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ping)
  if (has_ping()) {
    clear_has_Type();
    ::snakes::GameMessage_PingMsg* temp = Type_.ping_;
    Type_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_ping(::snakes::GameMessage_PingMsg* ping) {
  clear_Type();
  if (ping) {
    set_has_ping();
    Type_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ping)
}

// optional .snakes.GameMessage.SteerMsg steer = 3;
inline bool GameMessage::has_steer() const {
  return Type_case() == kSteer;
}
inline void GameMessage::set_has_steer() {
  _oneof_case_[0] = kSteer;
}
inline void GameMessage::clear_steer() {
  if (has_steer()) {
    delete Type_.steer_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_SteerMsg& GameMessage::steer() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.steer)
  return has_steer()
      ? *Type_.steer_
      : ::snakes::GameMessage_SteerMsg::default_instance();
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::mutable_steer() {
  if (!has_steer()) {
    clear_Type();
    set_has_steer();
    Type_.steer_ = new ::snakes::GameMessage_SteerMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.steer)
  return Type_.steer_;
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::release_steer() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.steer)
  if (has_steer()) {
    clear_has_Type();
    ::snakes::GameMessage_SteerMsg* temp = Type_.steer_;
    Type_.steer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_steer(::snakes::GameMessage_SteerMsg* steer) {
  clear_Type();
  if (steer) {
    set_has_steer();
    Type_.steer_ = steer;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.steer)
}

// optional .snakes.GameMessage.AckMsg ack = 4;
inline bool GameMessage::has_ack() const {
  return Type_case() == kAck;
}
inline void GameMessage::set_has_ack() {
  _oneof_case_[0] = kAck;
}
inline void GameMessage::clear_ack() {
  if (has_ack()) {
    delete Type_.ack_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_AckMsg& GameMessage::ack() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ack)
  return has_ack()
      ? *Type_.ack_
      : ::snakes::GameMessage_AckMsg::default_instance();
}
inline ::snakes::GameMessage_AckMsg* GameMessage::mutable_ack() {
  if (!has_ack()) {
    clear_Type();
    set_has_ack();
    Type_.ack_ = new ::snakes::GameMessage_AckMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ack)
  return Type_.ack_;
}
inline ::snakes::GameMessage_AckMsg* GameMessage::release_ack() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ack)
  if (has_ack()) {
    clear_has_Type();
    ::snakes::GameMessage_AckMsg* temp = Type_.ack_;
    Type_.ack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_ack(::snakes::GameMessage_AckMsg* ack) {
  clear_Type();
  if (ack) {
    set_has_ack();
    Type_.ack_ = ack;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ack)
}

// optional .snakes.GameMessage.StateMsg state = 5;
inline bool GameMessage::has_state() const {
  return Type_case() == kState;
}
inline void GameMessage::set_has_state() {
  _oneof_case_[0] = kState;
}
inline void GameMessage::clear_state() {
  if (has_state()) {
    delete Type_.state_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_StateMsg& GameMessage::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.state)
  return has_state()
      ? *Type_.state_
      : ::snakes::GameMessage_StateMsg::default_instance();
}
inline ::snakes::GameMessage_StateMsg* GameMessage::mutable_state() {
  if (!has_state()) {
    clear_Type();
    set_has_state();
    Type_.state_ = new ::snakes::GameMessage_StateMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.state)
  return Type_.state_;
}
inline ::snakes::GameMessage_StateMsg* GameMessage::release_state() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.state)
  if (has_state()) {
    clear_has_Type();
    ::snakes::GameMessage_StateMsg* temp = Type_.state_;
    Type_.state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_state(::snakes::GameMessage_StateMsg* state) {
  clear_Type();
  if (state) {
    set_has_state();
    Type_.state_ = state;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.state)
}

// optional .snakes.GameMessage.AnnouncementMsg announcement = 6;
inline bool GameMessage::has_announcement() const {
  return Type_case() == kAnnouncement;
}
inline void GameMessage::set_has_announcement() {
  _oneof_case_[0] = kAnnouncement;
}
inline void GameMessage::clear_announcement() {
  if (has_announcement()) {
    delete Type_.announcement_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_AnnouncementMsg& GameMessage::announcement() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.announcement)
  return has_announcement()
      ? *Type_.announcement_
      : ::snakes::GameMessage_AnnouncementMsg::default_instance();
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::mutable_announcement() {
  if (!has_announcement()) {
    clear_Type();
    set_has_announcement();
    Type_.announcement_ = new ::snakes::GameMessage_AnnouncementMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.announcement)
  return Type_.announcement_;
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::release_announcement() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.announcement)
  if (has_announcement()) {
    clear_has_Type();
    ::snakes::GameMessage_AnnouncementMsg* temp = Type_.announcement_;
    Type_.announcement_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement) {
  clear_Type();
  if (announcement) {
    set_has_announcement();
    Type_.announcement_ = announcement;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.announcement)
}

// optional .snakes.GameMessage.JoinMsg join = 7;
inline bool GameMessage::has_join() const {
  return Type_case() == kJoin;
}
inline void GameMessage::set_has_join() {
  _oneof_case_[0] = kJoin;
}
inline void GameMessage::clear_join() {
  if (has_join()) {
    delete Type_.join_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_JoinMsg& GameMessage::join() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.join)
  return has_join()
      ? *Type_.join_
      : ::snakes::GameMessage_JoinMsg::default_instance();
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::mutable_join() {
  if (!has_join()) {
    clear_Type();
    set_has_join();
    Type_.join_ = new ::snakes::GameMessage_JoinMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.join)
  return Type_.join_;
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::release_join() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.join)
  if (has_join()) {
    clear_has_Type();
    ::snakes::GameMessage_JoinMsg* temp = Type_.join_;
    Type_.join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_join(::snakes::GameMessage_JoinMsg* join) {
  clear_Type();
  if (join) {
    set_has_join();
    Type_.join_ = join;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.join)
}

// optional .snakes.GameMessage.ErrorMsg error = 8;
inline bool GameMessage::has_error() const {
  return Type_case() == kError;
}
inline void GameMessage::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void GameMessage::clear_error() {
  if (has_error()) {
    delete Type_.error_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_ErrorMsg& GameMessage::error() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.error)
  return has_error()
      ? *Type_.error_
      : ::snakes::GameMessage_ErrorMsg::default_instance();
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::mutable_error() {
  if (!has_error()) {
    clear_Type();
    set_has_error();
    Type_.error_ = new ::snakes::GameMessage_ErrorMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.error)
  return Type_.error_;
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::release_error() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.error)
  if (has_error()) {
    clear_has_Type();
    ::snakes::GameMessage_ErrorMsg* temp = Type_.error_;
    Type_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_error(::snakes::GameMessage_ErrorMsg* error) {
  clear_Type();
  if (error) {
    set_has_error();
    Type_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.error)
}

// optional .snakes.GameMessage.RoleChangeMsg role_change = 9;
inline bool GameMessage::has_role_change() const {
  return Type_case() == kRoleChange;
}
inline void GameMessage::set_has_role_change() {
  _oneof_case_[0] = kRoleChange;
}
inline void GameMessage::clear_role_change() {
  if (has_role_change()) {
    delete Type_.role_change_;
    clear_has_Type();
  }
}
inline  const ::snakes::GameMessage_RoleChangeMsg& GameMessage::role_change() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.role_change)
  return has_role_change()
      ? *Type_.role_change_
      : ::snakes::GameMessage_RoleChangeMsg::default_instance();
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::mutable_role_change() {
  if (!has_role_change()) {
    clear_Type();
    set_has_role_change();
    Type_.role_change_ = new ::snakes::GameMessage_RoleChangeMsg;
  }
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.role_change)
  return Type_.role_change_;
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::release_role_change() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.role_change)
  if (has_role_change()) {
    clear_has_Type();
    ::snakes::GameMessage_RoleChangeMsg* temp = Type_.role_change_;
    Type_.role_change_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GameMessage::set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change) {
  clear_Type();
  if (role_change) {
    set_has_role_change();
    Type_.role_change_ = role_change;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.role_change)
}

inline bool GameMessage::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void GameMessage::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline GameMessage::TypeCase GameMessage::Type_case() const {
  return GameMessage::TypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace snakes

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::snakes::GameState_Snake_SnakeState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::GameState_Snake_SnakeState>() {
  return ::snakes::GameState_Snake_SnakeState_descriptor();
}
template <> struct is_proto_enum< ::snakes::NodeRole> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::NodeRole>() {
  return ::snakes::NodeRole_descriptor();
}
template <> struct is_proto_enum< ::snakes::PlayerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::PlayerType>() {
  return ::snakes::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::snakes::Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::Direction>() {
  return ::snakes::Direction_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_snakes_2eproto__INCLUDED
