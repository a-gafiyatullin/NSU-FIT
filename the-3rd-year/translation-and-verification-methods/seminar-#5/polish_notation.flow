import runtime;
import string;
import lingo/pegcode/driver;

ArExp ::= ArSum, ArMult, ArInt;
ArSum(lhs : ArExp, rhs : ArExp);
ArMult(lhs : ArExp, rhs : ArExp);
ArInt(val : int);

s2ar(s: string) -> ArExp {
    gram = "#include ex.gram";
    parsic(compilePegGrammar(gram), s, defaultPegActions);
}

ArRPN ::= OpRPN, ValRPN;
ValRPN(val: int);
OpRPN ::= PlusRPN, MultRPN;
PlusRPN();
MultRPN();

ar2rpn(e: ArExp) -> [ArRPN] {
	switch(e: ArExp) {
		ArSum(a, b) : concat(concat([PlusRPN()], ar2rpn(a)), ar2rpn(b));
		ArMult(a, b) : concat(concat([MultRPN()], ar2rpn(a)), ar2rpn(b));
		ArInt(a) : [ValRPN(a)];
	}
}

ar2rpnsize(e: ArExp) -> int {
        switch(e: ArExp) {
                ArSum(a, b) : 1 + ar2rpnsize(a) +  ar2rpnsize(b);
                ArMult(a, b) : 1 + ar2rpnsize(a) +  ar2rpnsize(b);
                ArInt(a) : 1;
        }
}

rpn2ar(e : [ArRPN], i : int) -> ArExp {
	switch(e[i]) {
		PlusRPN() : {
		    subtree = rpn2ar(e, i + 1);
        	len = ar2rpnsize(subtree) + 1;
		    ArSum(subtree, rpn2ar(e, i + len))
		};
		MultRPN() : {
		    subtree = rpn2ar(e, i + 1);
    	    len = ar2rpnsize(subtree) + 1;
		    ArMult(subtree, rpn2ar(e, i + len));
		}
		ValRPN(a) : ArInt(a);
	}
}

ar2s(e : ArExp, str : string) -> string {
    switch(e : ArExp) {
        ArSum(a, b) : str + ar2s(a, str) + "+" + ar2s(b, str);
        ArMult(a, b) : str + ar2s(a, str) + "*" + ar2s(b, str);
        ArInt(a) : str + i2s(a);
    }
}

main() {
    str = "(   1   + (   3   * 3    )    )";
    e = s2ar(str);
    r = ar2rpn(e);
    iter(r, \v -> {
			switch(v) {
				PlusRPN() : println("+");
				MultRPN() : println("*");
				ValRPN(a) : println(i2s(a));
			}
		  });
    println(ar2s(rpn2ar(r, 0), ""));
}